(window.webpackJsonp=window.webpackJsonp||[]).push([[156],{1404:function(e,t,r){"use strict";r.d(t,"a",(function(){return f}));var n=r(3),o=r(833),l=r(845);let c,h,d;class f extends n.Loader{constructor(e){super(e)}load(e,t,r,o){const l=this,path=""===l.path?n.LoaderUtils.extractUrlBase(e):l.path,c=new n.FileLoader(this.manager);c.setPath(l.path),c.setResponseType("arraybuffer"),c.setRequestHeader(l.requestHeader),c.setWithCredentials(l.withCredentials),c.load(e,(function(r){try{t(l.parse(r,path))}catch(t){o?o(t):console.error(t),l.manager.itemError(e)}}),r,o)}parse(e,path){if(function(e){const t="Kaydara FBX Binary  \0";return e.byteLength>=t.length&&t===k(e,0,t.length)}(e))c=(new I).parse(e);else{const t=k(e);if(!function(text){const e=["K","a","y","d","a","r","a","\\","F","B","X","\\","B","i","n","a","r","y","\\","\\"];let cursor=0;function t(e){const t=text[e-1];return text=text.slice(cursor+e),cursor++,t}for(let i=0;i<e.length;++i){if(t(1)===e[i])return!1}return!0}(t))throw new Error("THREE.FBXLoader: Unknown format.");if(M(t)<7e3)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+M(t));c=(new w).parse(t)}const t=new n.TextureLoader(this.manager).setPath(this.resourcePath||path).setCrossOrigin(this.crossOrigin);return new m(t,this.manager).parse(c)}}class m{constructor(e,t){this.textureLoader=e,this.manager=t}parse(){h=this.parseConnections();const e=this.parseImages(),t=this.parseTextures(e),r=this.parseMaterials(t),n=this.parseDeformers(),o=(new v).parse(n);return this.parseScene(n,o,r),d}parseConnections(){const e=new Map;if("Connections"in c){c.Connections.connections.forEach((function(t){const r=t[0],n=t[1],o=t[2];e.has(r)||e.set(r,{parents:[],children:[]});const l={ID:n,relationship:o};e.get(r).parents.push(l),e.has(n)||e.set(n,{parents:[],children:[]});const c={ID:r,relationship:o};e.get(n).children.push(c)}))}return e}parseImages(){const e={},t={};if("Video"in c.Objects){const r=c.Objects.Video;for(const n in r){const o=r[n];if(e[parseInt(n)]=o.RelativeFilename||o.Filename,"Content"in o){const e=o.Content instanceof ArrayBuffer&&o.Content.byteLength>0,l="string"==typeof o.Content&&""!==o.Content;if(e||l){const image=this.parseImage(r[n]);t[o.RelativeFilename||o.Filename]=image}}}}for(const r in e){const n=e[r];void 0!==t[n]?e[r]=t[n]:e[r]=e[r].split("\\").pop()}return e}parseImage(e){const content=e.Content,t=e.RelativeFilename||e.Filename,r=t.slice(t.lastIndexOf(".")+1).toLowerCase();let n;switch(r){case"bmp":n="image/bmp";break;case"jpg":case"jpeg":n="image/jpeg";break;case"png":n="image/png";break;case"tif":n="image/tiff";break;case"tga":null===this.manager.getHandler(".tga")&&console.warn("FBXLoader: TGA loader not found, skipping ",t),n="image/tga";break;default:return void console.warn('FBXLoader: Image type "'+r+'" is not supported.')}if("string"==typeof content)return"data:"+n+";base64,"+content;{const e=new Uint8Array(content);return window.URL.createObjectURL(new Blob([e],{type:n}))}}parseTextures(e){const t=new Map;if("Texture"in c.Objects){const r=c.Objects.Texture;for(const n in r){const o=this.parseTexture(r[n],e);t.set(parseInt(n),o)}}return t}parseTexture(e,t){const r=this.loadTexture(e,t);r.ID=e.id,r.name=e.attrName;const o=e.WrapModeU,l=e.WrapModeV,c=void 0!==o?o.value:0,h=void 0!==l?l.value:0;if(r.wrapS=0===c?n.RepeatWrapping:n.ClampToEdgeWrapping,r.wrapT=0===h?n.RepeatWrapping:n.ClampToEdgeWrapping,"Scaling"in e){const t=e.Scaling.value;r.repeat.x=t[0],r.repeat.y=t[1]}return r}loadTexture(e,t){let r;const o=this.textureLoader.path,l=h.get(e.id).children;let c;void 0!==l&&l.length>0&&void 0!==t[l[0].ID]&&(r=t[l[0].ID],0!==r.indexOf("blob:")&&0!==r.indexOf("data:")||this.textureLoader.setPath(void 0));const d=e.FileName.slice(-3).toLowerCase();if("tga"===d){const t=this.manager.getHandler(".tga");null===t?(console.warn("FBXLoader: TGA loader not found, creating placeholder texture for",e.RelativeFilename),c=new n.Texture):(t.setPath(this.textureLoader.path),c=t.load(r))}else"psd"===d?(console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for",e.RelativeFilename),c=new n.Texture):c=this.textureLoader.load(r);return this.textureLoader.setPath(o),c}parseMaterials(e){const t=new Map;if("Material"in c.Objects){const r=c.Objects.Material;for(const n in r){const o=this.parseMaterial(r[n],e);null!==o&&t.set(parseInt(n),o)}}return t}parseMaterial(e,t){const r=e.id,o=e.attrName;let l=e.ShadingModel;if("object"==typeof l&&(l=l.value),!h.has(r))return null;const c=this.parseParameters(e,t,r);let d;switch(l.toLowerCase()){case"phong":d=new n.MeshPhongMaterial;break;case"lambert":d=new n.MeshLambertMaterial;break;default:console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.',l),d=new n.MeshPhongMaterial}return d.setValues(c),d.name=o,d}parseParameters(e,t,r){const o={};e.BumpFactor&&(o.bumpScale=e.BumpFactor.value),e.Diffuse?o.color=(new n.Color).fromArray(e.Diffuse.value):!e.DiffuseColor||"Color"!==e.DiffuseColor.type&&"ColorRGB"!==e.DiffuseColor.type||(o.color=(new n.Color).fromArray(e.DiffuseColor.value)),e.DisplacementFactor&&(o.displacementScale=e.DisplacementFactor.value),e.Emissive?o.emissive=(new n.Color).fromArray(e.Emissive.value):!e.EmissiveColor||"Color"!==e.EmissiveColor.type&&"ColorRGB"!==e.EmissiveColor.type||(o.emissive=(new n.Color).fromArray(e.EmissiveColor.value)),e.EmissiveFactor&&(o.emissiveIntensity=parseFloat(e.EmissiveFactor.value)),e.Opacity&&(o.opacity=parseFloat(e.Opacity.value)),o.opacity<1&&(o.transparent=!0),e.ReflectionFactor&&(o.reflectivity=e.ReflectionFactor.value),e.Shininess&&(o.shininess=e.Shininess.value),e.Specular?o.specular=(new n.Color).fromArray(e.Specular.value):e.SpecularColor&&"Color"===e.SpecularColor.type&&(o.specular=(new n.Color).fromArray(e.SpecularColor.value));const l=this;return h.get(r).children.forEach((function(e){const r=e.relationship;switch(r){case"Bump":o.bumpMap=l.getTexture(t,e.ID);break;case"Maya|TEX_ao_map":o.aoMap=l.getTexture(t,e.ID);break;case"DiffuseColor":case"Maya|TEX_color_map":o.map=l.getTexture(t,e.ID),void 0!==o.map&&(o.map.encoding=n.sRGBEncoding);break;case"DisplacementColor":o.displacementMap=l.getTexture(t,e.ID);break;case"EmissiveColor":o.emissiveMap=l.getTexture(t,e.ID),void 0!==o.emissiveMap&&(o.emissiveMap.encoding=n.sRGBEncoding);break;case"NormalMap":case"Maya|TEX_normal_map":o.normalMap=l.getTexture(t,e.ID);break;case"ReflectionColor":o.envMap=l.getTexture(t,e.ID),void 0!==o.envMap&&(o.envMap.mapping=n.EquirectangularReflectionMapping,o.envMap.encoding=n.sRGBEncoding);break;case"SpecularColor":o.specularMap=l.getTexture(t,e.ID),void 0!==o.specularMap&&(o.specularMap.encoding=n.sRGBEncoding);break;case"TransparentColor":case"TransparencyFactor":o.alphaMap=l.getTexture(t,e.ID),o.transparent=!0;break;case"AmbientColor":case"ShininessExponent":case"SpecularFactor":case"VectorDisplacementColor":default:console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.",r)}})),o}getTexture(e,t){return"LayeredTexture"in c.Objects&&t in c.Objects.LayeredTexture&&(console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."),t=h.get(t).children[0].ID),e.get(t)}parseDeformers(){const e={},t={};if("Deformer"in c.Objects){const r=c.Objects.Deformer;for(const n in r){const o=r[n],l=h.get(parseInt(n));if("Skin"===o.attrType){const t=this.parseSkeleton(l,r);t.ID=n,l.parents.length>1&&console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."),t.geometryID=l.parents[0].ID,e[n]=t}else if("BlendShape"===o.attrType){const e={id:n};e.rawTargets=this.parseMorphTargets(l,r),e.id=n,l.parents.length>1&&console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."),t[n]=e}}}return{skeletons:e,morphTargets:t}}parseSkeleton(e,t){const r=[];return e.children.forEach((function(e){const o=t[e.ID];if("Cluster"!==o.attrType)return;const l={ID:e.ID,indices:[],weights:[],transformLink:(new n.Matrix4).fromArray(o.TransformLink.a)};"Indexes"in o&&(l.indices=o.Indexes.a,l.weights=o.Weights.a),r.push(l)})),{rawBones:r,bones:[]}}parseMorphTargets(e,t){const r=[];for(let i=0;i<e.children.length;i++){const n=e.children[i],o=t[n.ID],l={name:o.attrName,initialWeight:o.DeformPercent,id:o.id,fullWeights:o.FullWeights.a};if("BlendShapeChannel"!==o.attrType)return;l.geoID=h.get(parseInt(n.ID)).children.filter((function(e){return void 0===e.relationship}))[0].ID,r.push(l)}return r}parseScene(e,t,r){d=new n.Group;const o=this.parseModels(e.skeletons,t,r),l=c.Objects.Model,f=this;o.forEach((function(e){const t=l[e.ID];f.setLookAtProperties(e,t);h.get(e.ID).parents.forEach((function(t){const r=o.get(t.ID);void 0!==r&&r.add(e)})),null===e.parent&&d.add(e)})),this.bindSkeleton(e.skeletons,t,o),this.createAmbientLight(),d.traverse((function(e){if(e.userData.transformData){e.parent&&(e.userData.transformData.parentMatrix=e.parent.matrix,e.userData.transformData.parentMatrixWorld=e.parent.matrixWorld);const t=C(e.userData.transformData);e.applyMatrix4(t),e.updateWorldMatrix()}}));const m=(new y).parse();1===d.children.length&&d.children[0].isGroup&&(d.children[0].animations=m,d=d.children[0]),d.animations=m}parseModels(e,t,r){const o=new Map,l=c.Objects.Model;for(const c in l){const d=parseInt(c),f=l[c],m=h.get(d);let v=this.buildSkeleton(m,e,d,f.attrName);if(!v){switch(f.attrType){case"Camera":v=this.createCamera(m);break;case"Light":v=this.createLight(m);break;case"Mesh":v=this.createMesh(m,t,r);break;case"NurbsCurve":v=this.createCurve(m,t);break;case"LimbNode":case"Root":v=new n.Bone;break;case"Null":default:v=new n.Group}v.name=f.attrName?n.PropertyBinding.sanitizeNodeName(f.attrName):"",v.ID=d}this.getTransformData(v,f),o.set(d,v)}return o}buildSkeleton(e,t,r,o){let l=null;return e.parents.forEach((function(e){for(const c in t){const h=t[c];h.rawBones.forEach((function(t,i){if(t.ID===e.ID){const e=l;l=new n.Bone,l.matrixWorld.copy(t.transformLink),l.name=o?n.PropertyBinding.sanitizeNodeName(o):"",l.ID=r,h.bones[i]=l,null!==e&&l.add(e)}}))}})),l}createCamera(e){let t,r;if(e.children.forEach((function(e){const t=c.Objects.NodeAttribute[e.ID];void 0!==t&&(r=t)})),void 0===r)t=new n.Object3D;else{let e=0;void 0!==r.CameraProjectionType&&1===r.CameraProjectionType.value&&(e=1);let o=1;void 0!==r.NearPlane&&(o=r.NearPlane.value/1e3);let l=1e3;void 0!==r.FarPlane&&(l=r.FarPlane.value/1e3);let c=window.innerWidth,h=window.innerHeight;void 0!==r.AspectWidth&&void 0!==r.AspectHeight&&(c=r.AspectWidth.value,h=r.AspectHeight.value);const d=c/h;let f=45;void 0!==r.FieldOfView&&(f=r.FieldOfView.value);const m=r.FocalLength?r.FocalLength.value:null;switch(e){case 0:t=new n.PerspectiveCamera(f,d,o,l),null!==m&&t.setFocalLength(m);break;case 1:t=new n.OrthographicCamera(-c/2,c/2,h/2,-h/2,o,l);break;default:console.warn("THREE.FBXLoader: Unknown camera type "+e+"."),t=new n.Object3D}}return t}createLight(e){let t,r;if(e.children.forEach((function(e){const t=c.Objects.NodeAttribute[e.ID];void 0!==t&&(r=t)})),void 0===r)t=new n.Object3D;else{let e;e=void 0===r.LightType?0:r.LightType.value;let o=16777215;void 0!==r.Color&&(o=(new n.Color).fromArray(r.Color.value));let l=void 0===r.Intensity?1:r.Intensity.value/100;void 0!==r.CastLightOnObject&&0===r.CastLightOnObject.value&&(l=0);let c=0;void 0!==r.FarAttenuationEnd&&(c=void 0!==r.EnableFarAttenuation&&0===r.EnableFarAttenuation.value?0:r.FarAttenuationEnd.value);const h=1;switch(e){case 0:t=new n.PointLight(o,l,c,h);break;case 1:t=new n.DirectionalLight(o,l);break;case 2:let e=Math.PI/3;void 0!==r.InnerAngle&&(e=n.MathUtils.degToRad(r.InnerAngle.value));let d=0;void 0!==r.OuterAngle&&(d=n.MathUtils.degToRad(r.OuterAngle.value),d=Math.max(d,1)),t=new n.SpotLight(o,l,c,e,d,h);break;default:console.warn("THREE.FBXLoader: Unknown light type "+r.LightType.value+", defaulting to a PointLight."),t=new n.PointLight(o,l)}void 0!==r.CastShadows&&1===r.CastShadows.value&&(t.castShadow=!0)}return t}createMesh(e,t,r){let o,l=null,c=null;const h=[];return e.children.forEach((function(e){t.has(e.ID)&&(l=t.get(e.ID)),r.has(e.ID)&&h.push(r.get(e.ID))})),h.length>1?c=h:h.length>0?c=h[0]:(c=new n.MeshPhongMaterial({color:13421772}),h.push(c)),"color"in l.attributes&&h.forEach((function(e){e.vertexColors=!0})),l.FBX_Deformer?(o=new n.SkinnedMesh(l,c),o.normalizeSkinWeights()):o=new n.Mesh(l,c),o}createCurve(e,t){const r=e.children.reduce((function(e,r){return t.has(r.ID)&&(e=t.get(r.ID)),e}),null),o=new n.LineBasicMaterial({color:3342591,linewidth:1});return new n.Line(r,o)}getTransformData(e,t){const r={};"InheritType"in t&&(r.inheritType=parseInt(t.InheritType.value)),r.eulerOrder="RotationOrder"in t?N(t.RotationOrder.value):"ZYX","Lcl_Translation"in t&&(r.translation=t.Lcl_Translation.value),"PreRotation"in t&&(r.preRotation=t.PreRotation.value),"Lcl_Rotation"in t&&(r.rotation=t.Lcl_Rotation.value),"PostRotation"in t&&(r.postRotation=t.PostRotation.value),"Lcl_Scaling"in t&&(r.scale=t.Lcl_Scaling.value),"ScalingOffset"in t&&(r.scalingOffset=t.ScalingOffset.value),"ScalingPivot"in t&&(r.scalingPivot=t.ScalingPivot.value),"RotationOffset"in t&&(r.rotationOffset=t.RotationOffset.value),"RotationPivot"in t&&(r.rotationPivot=t.RotationPivot.value),e.userData.transformData=r}setLookAtProperties(e,t){if("LookAtProperty"in t){h.get(e.ID).children.forEach((function(t){if("LookAtProperty"===t.relationship){const r=c.Objects.Model[t.ID];if("Lcl_Translation"in r){const t=r.Lcl_Translation.value;void 0!==e.target?(e.target.position.fromArray(t),d.add(e.target)):e.lookAt((new n.Vector3).fromArray(t))}}}))}}bindSkeleton(e,t,r){const o=this.parsePoseNodes();for(const l in e){const c=e[l];h.get(parseInt(c.ID)).parents.forEach((function(e){if(t.has(e.ID)){const t=e.ID;h.get(t).parents.forEach((function(e){if(r.has(e.ID)){r.get(e.ID).bind(new n.Skeleton(c.bones),o[e.ID])}}))}}))}}parsePoseNodes(){const e={};if("Pose"in c.Objects){const t=c.Objects.Pose;for(const r in t)if("BindPose"===t[r].attrType&&t[r].NbPoseNodes>0){const o=t[r].PoseNode;Array.isArray(o)?o.forEach((function(t){e[t.Node]=(new n.Matrix4).fromArray(t.Matrix.a)})):e[o.Node]=(new n.Matrix4).fromArray(o.Matrix.a)}}return e}createAmbientLight(){if("GlobalSettings"in c&&"AmbientColor"in c.GlobalSettings){const e=c.GlobalSettings.AmbientColor.value,t=e[0],g=e[1],b=e[2];if(0!==t||0!==g||0!==b){const e=new n.Color(t,g,b);d.add(new n.AmbientLight(e,1))}}}}class v{parse(e){const t=new Map;if("Geometry"in c.Objects){const r=c.Objects.Geometry;for(const n in r){const o=h.get(parseInt(n)),l=this.parseGeometry(o,r[n],e);t.set(parseInt(n),l)}}return t}parseGeometry(e,t,r){switch(t.attrType){case"Mesh":return this.parseMeshGeometry(e,t,r);case"NurbsCurve":return this.parseNurbsGeometry(t)}}parseMeshGeometry(e,t,r){const n=r.skeletons,o=[],l=e.parents.map((function(e){return c.Objects.Model[e.ID]}));if(0===l.length)return;const h=e.children.reduce((function(e,t){return void 0!==n[t.ID]&&(e=n[t.ID]),e}),null);e.children.forEach((function(e){void 0!==r.morphTargets[e.ID]&&o.push(r.morphTargets[e.ID])}));const d=l[0],f={};"RotationOrder"in d&&(f.eulerOrder=N(d.RotationOrder.value)),"InheritType"in d&&(f.inheritType=parseInt(d.InheritType.value)),"GeometricTranslation"in d&&(f.translation=d.GeometricTranslation.value),"GeometricRotation"in d&&(f.rotation=d.GeometricRotation.value),"GeometricScaling"in d&&(f.scale=d.GeometricScaling.value);const m=C(f);return this.genGeometry(t,h,o,m)}genGeometry(e,t,r,o){const l=new n.BufferGeometry;e.attrName&&(l.name=e.attrName);const c=this.parseGeoNode(e,t),h=this.genBuffers(c),d=new n.Float32BufferAttribute(h.vertex,3);if(d.applyMatrix4(o),l.setAttribute("position",d),h.colors.length>0&&l.setAttribute("color",new n.Float32BufferAttribute(h.colors,3)),t&&(l.setAttribute("skinIndex",new n.Uint16BufferAttribute(h.weightsIndices,4)),l.setAttribute("skinWeight",new n.Float32BufferAttribute(h.vertexWeights,4)),l.FBX_Deformer=t),h.normal.length>0){const e=(new n.Matrix3).getNormalMatrix(o),t=new n.Float32BufferAttribute(h.normal,3);t.applyNormalMatrix(e),l.setAttribute("normal",t)}if(h.uvs.forEach((function(e,i){let t="uv"+(i+1).toString();0===i&&(t="uv"),l.setAttribute(t,new n.Float32BufferAttribute(h.uvs[i],2))})),c.material&&"AllSame"!==c.material.mappingType){let e=h.materialIndex[0],t=0;if(h.materialIndex.forEach((function(r,i){r!==e&&(l.addGroup(t,i-t,e),e=r,t=i)})),l.groups.length>0){const t=l.groups[l.groups.length-1],r=t.start+t.count;r!==h.materialIndex.length&&l.addGroup(r,h.materialIndex.length-r,e)}0===l.groups.length&&l.addGroup(0,h.materialIndex.length,h.materialIndex[0])}return this.addMorphTargets(l,e,r,o),l}parseGeoNode(e,t){const r={};if(r.vertexPositions=void 0!==e.Vertices?e.Vertices.a:[],r.vertexIndices=void 0!==e.PolygonVertexIndex?e.PolygonVertexIndex.a:[],e.LayerElementColor&&(r.color=this.parseVertexColors(e.LayerElementColor[0])),e.LayerElementMaterial&&(r.material=this.parseMaterialIndices(e.LayerElementMaterial[0])),e.LayerElementNormal&&(r.normal=this.parseNormals(e.LayerElementNormal[0])),e.LayerElementUV){r.uv=[];let i=0;for(;e.LayerElementUV[i];)e.LayerElementUV[i].UV&&r.uv.push(this.parseUVs(e.LayerElementUV[i])),i++}return r.weightTable={},null!==t&&(r.skeleton=t,t.rawBones.forEach((function(e,i){e.indices.forEach((function(t,n){void 0===r.weightTable[t]&&(r.weightTable[t]=[]),r.weightTable[t].push({id:i,weight:e.weights[n]})}))}))),r}genBuffers(e){const t={vertex:[],normal:[],colors:[],uvs:[],materialIndex:[],vertexWeights:[],weightsIndices:[]};let r=0,n=0,o=!1,l=[],c=[],h=[],d=[],f=[],m=[];const v=this;return e.vertexIndices.forEach((function(y,w){let I,x=!1;y<0&&(y^=-1,x=!0);let T=[],M=[];if(l.push(3*y,3*y+1,3*y+2),e.color){const data=D(w,r,y,e.color);h.push(data[0],data[1],data[2])}if(e.skeleton){if(void 0!==e.weightTable[y]&&e.weightTable[y].forEach((function(e){M.push(e.weight),T.push(e.id)})),M.length>4){o||(console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."),o=!0);const e=[0,0,0,0],t=[0,0,0,0];M.forEach((function(r,n){let o=r,l=T[n];t.forEach((function(t,r,n){if(o>t){n[r]=o,o=t;const c=e[r];e[r]=l,l=c}}))})),T=e,M=t}for(;M.length<4;)M.push(0),T.push(0);for(let i=0;i<4;++i)f.push(M[i]),m.push(T[i])}if(e.normal){const data=D(w,r,y,e.normal);c.push(data[0],data[1],data[2])}e.material&&"AllSame"!==e.material.mappingType&&(I=D(w,r,y,e.material)[0]),e.uv&&e.uv.forEach((function(e,i){const data=D(w,r,y,e);void 0===d[i]&&(d[i]=[]),d[i].push(data[0]),d[i].push(data[1])})),n++,x&&(v.genFace(t,e,l,I,c,h,d,f,m,n),r++,n=0,l=[],c=[],h=[],d=[],f=[],m=[])})),t}genFace(e,t,r,n,o,l,c,h,d,f){for(let i=2;i<f;i++)e.vertex.push(t.vertexPositions[r[0]]),e.vertex.push(t.vertexPositions[r[1]]),e.vertex.push(t.vertexPositions[r[2]]),e.vertex.push(t.vertexPositions[r[3*(i-1)]]),e.vertex.push(t.vertexPositions[r[3*(i-1)+1]]),e.vertex.push(t.vertexPositions[r[3*(i-1)+2]]),e.vertex.push(t.vertexPositions[r[3*i]]),e.vertex.push(t.vertexPositions[r[3*i+1]]),e.vertex.push(t.vertexPositions[r[3*i+2]]),t.skeleton&&(e.vertexWeights.push(h[0]),e.vertexWeights.push(h[1]),e.vertexWeights.push(h[2]),e.vertexWeights.push(h[3]),e.vertexWeights.push(h[4*(i-1)]),e.vertexWeights.push(h[4*(i-1)+1]),e.vertexWeights.push(h[4*(i-1)+2]),e.vertexWeights.push(h[4*(i-1)+3]),e.vertexWeights.push(h[4*i]),e.vertexWeights.push(h[4*i+1]),e.vertexWeights.push(h[4*i+2]),e.vertexWeights.push(h[4*i+3]),e.weightsIndices.push(d[0]),e.weightsIndices.push(d[1]),e.weightsIndices.push(d[2]),e.weightsIndices.push(d[3]),e.weightsIndices.push(d[4*(i-1)]),e.weightsIndices.push(d[4*(i-1)+1]),e.weightsIndices.push(d[4*(i-1)+2]),e.weightsIndices.push(d[4*(i-1)+3]),e.weightsIndices.push(d[4*i]),e.weightsIndices.push(d[4*i+1]),e.weightsIndices.push(d[4*i+2]),e.weightsIndices.push(d[4*i+3])),t.color&&(e.colors.push(l[0]),e.colors.push(l[1]),e.colors.push(l[2]),e.colors.push(l[3*(i-1)]),e.colors.push(l[3*(i-1)+1]),e.colors.push(l[3*(i-1)+2]),e.colors.push(l[3*i]),e.colors.push(l[3*i+1]),e.colors.push(l[3*i+2])),t.material&&"AllSame"!==t.material.mappingType&&(e.materialIndex.push(n),e.materialIndex.push(n),e.materialIndex.push(n)),t.normal&&(e.normal.push(o[0]),e.normal.push(o[1]),e.normal.push(o[2]),e.normal.push(o[3*(i-1)]),e.normal.push(o[3*(i-1)+1]),e.normal.push(o[3*(i-1)+2]),e.normal.push(o[3*i]),e.normal.push(o[3*i+1]),e.normal.push(o[3*i+2])),t.uv&&t.uv.forEach((function(t,r){void 0===e.uvs[r]&&(e.uvs[r]=[]),e.uvs[r].push(c[r][0]),e.uvs[r].push(c[r][1]),e.uvs[r].push(c[r][2*(i-1)]),e.uvs[r].push(c[r][2*(i-1)+1]),e.uvs[r].push(c[r][2*i]),e.uvs[r].push(c[r][2*i+1])}))}addMorphTargets(e,t,r,n){if(0===r.length)return;e.morphTargetsRelative=!0,e.morphAttributes.position=[];const o=this;r.forEach((function(r){r.rawTargets.forEach((function(r){const l=c.Objects.Geometry[r.geoID];void 0!==l&&o.genMorphGeometry(e,t,l,n,r.name)}))}))}genMorphGeometry(e,t,r,o,l){const c=void 0!==t.PolygonVertexIndex?t.PolygonVertexIndex.a:[],h=void 0!==r.Vertices?r.Vertices.a:[],d=void 0!==r.Indexes?r.Indexes.a:[],f=3*e.attributes.position.count,m=new Float32Array(f);for(let i=0;i<d.length;i++){const e=3*d[i];m[e]=h[3*i],m[e+1]=h[3*i+1],m[e+2]=h[3*i+2]}const v={vertexIndices:c,vertexPositions:m},y=this.genBuffers(v),w=new n.Float32BufferAttribute(y.vertex,3);w.name=l||r.attrName,w.applyMatrix4(o),e.morphAttributes.position.push(w)}parseNormals(e){const t=e.MappingInformationType,r=e.ReferenceInformationType,n=e.Normals.a;let o=[];return"IndexToDirect"===r&&("NormalIndex"in e?o=e.NormalIndex.a:"NormalsIndex"in e&&(o=e.NormalsIndex.a)),{dataSize:3,buffer:n,indices:o,mappingType:t,referenceType:r}}parseUVs(e){const t=e.MappingInformationType,r=e.ReferenceInformationType,n=e.UV.a;let o=[];return"IndexToDirect"===r&&(o=e.UVIndex.a),{dataSize:2,buffer:n,indices:o,mappingType:t,referenceType:r}}parseVertexColors(e){const t=e.MappingInformationType,r=e.ReferenceInformationType,n=e.Colors.a;let o=[];return"IndexToDirect"===r&&(o=e.ColorIndex.a),{dataSize:4,buffer:n,indices:o,mappingType:t,referenceType:r}}parseMaterialIndices(e){const t=e.MappingInformationType,r=e.ReferenceInformationType;if("NoMappingInformation"===t)return{dataSize:1,buffer:[0],indices:[0],mappingType:"AllSame",referenceType:r};const n=e.Materials.a,o=[];for(let i=0;i<n.length;++i)o.push(i);return{dataSize:1,buffer:n,indices:o,mappingType:t,referenceType:r}}parseNurbsGeometry(e){if(void 0===l.a)return console.error("THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry."),new n.BufferGeometry;const t=parseInt(e.Order);if(isNaN(t))return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s",e.Order,e.id),new n.BufferGeometry;const r=t-1,o=e.KnotVector.a,c=[],h=e.Points.a;for(let i=0,e=h.length;i<e;i+=4)c.push((new n.Vector4).fromArray(h,i));let d,f;if("Closed"===e.Form)c.push(c[0]);else if("Periodic"===e.Form){d=r,f=o.length-1-d;for(let i=0;i<r;++i)c.push(c[i])}const m=new l.a(r,o,c,d,f).getPoints(12*c.length);return(new n.BufferGeometry).setFromPoints(m)}}class y{parse(){const e=[],t=this.parseClips();if(void 0!==t)for(const r in t){const n=t[r],o=this.addClip(n);e.push(o)}return e}parseClips(){if(void 0===c.Objects.AnimationCurve)return;const e=this.parseAnimationCurveNodes();this.parseAnimationCurves(e);const t=this.parseAnimationLayers(e);return this.parseAnimStacks(t)}parseAnimationCurveNodes(){const e=c.Objects.AnimationCurveNode,t=new Map;for(const r in e){const n=e[r];if(null!==n.attrName.match(/S|R|T|DeformPercent/)){const e={id:n.id,attr:n.attrName,curves:{}};t.set(e.id,e)}}return t}parseAnimationCurves(e){const t=c.Objects.AnimationCurve;for(const r in t){const n={id:t[r].id,times:t[r].KeyTime.a.map(E),values:t[r].KeyValueFloat.a},o=h.get(n.id);if(void 0!==o){const t=o.parents[0].ID,r=o.parents[0].relationship;r.match(/X/)?e.get(t).curves.x=n:r.match(/Y/)?e.get(t).curves.y=n:r.match(/Z/)?e.get(t).curves.z=n:r.match(/d|DeformPercent/)&&e.has(t)&&(e.get(t).curves.morph=n)}}}parseAnimationLayers(e){const t=c.Objects.AnimationLayer,r=new Map;for(const o in t){const t=[],l=h.get(parseInt(o));if(void 0!==l){l.children.forEach((function(r,i){if(e.has(r.ID)){const o=e.get(r.ID);if(void 0!==o.curves.x||void 0!==o.curves.y||void 0!==o.curves.z){if(void 0===t[i]){const e=h.get(r.ID).parents.filter((function(e){return void 0!==e.relationship}))[0].ID;if(void 0!==e){const o=c.Objects.Model[e.toString()];if(void 0===o)return void console.warn("THREE.FBXLoader: Encountered a unused curve.",r);const l={modelName:o.attrName?n.PropertyBinding.sanitizeNodeName(o.attrName):"",ID:o.id,initialPosition:[0,0,0],initialRotation:[0,0,0],initialScale:[1,1,1]};d.traverse((function(e){e.ID===o.id&&(l.transform=e.matrix,e.userData.transformData&&(l.eulerOrder=e.userData.transformData.eulerOrder))})),l.transform||(l.transform=new n.Matrix4),"PreRotation"in o&&(l.preRotation=o.PreRotation.value),"PostRotation"in o&&(l.postRotation=o.PostRotation.value),t[i]=l}}t[i]&&(t[i][o.attr]=o)}else if(void 0!==o.curves.morph){if(void 0===t[i]){const e=h.get(r.ID).parents.filter((function(e){return void 0!==e.relationship}))[0].ID,o=h.get(e).parents[0].ID,l=h.get(o).parents[0].ID,d=h.get(l).parents[0].ID,f=c.Objects.Model[d],m={modelName:f.attrName?n.PropertyBinding.sanitizeNodeName(f.attrName):"",morphName:c.Objects.Deformer[e].attrName};t[i]=m}t[i][o.attr]=o}}})),r.set(parseInt(o),t)}}return r}parseAnimStacks(e){const t=c.Objects.AnimationStack,r={};for(const n in t){const o=h.get(parseInt(n)).children;o.length>1&&console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");const l=e.get(o[0].ID);r[n]={name:t[n].attrName,layer:l}}return r}addClip(e){let t=[];const r=this;return e.layer.forEach((function(e){t=t.concat(r.generateTracks(e))})),new n.AnimationClip(e.name,-1,t)}generateTracks(e){const t=[];let r=new n.Vector3,o=new n.Quaternion,l=new n.Vector3;if(e.transform&&e.transform.decompose(r,o,l),r=r.toArray(),o=(new n.Euler).setFromQuaternion(o,e.eulerOrder).toArray(),l=l.toArray(),void 0!==e.T&&Object.keys(e.T.curves).length>0){const n=this.generateVectorTrack(e.modelName,e.T.curves,r,"position");void 0!==n&&t.push(n)}if(void 0!==e.R&&Object.keys(e.R.curves).length>0){const r=this.generateRotationTrack(e.modelName,e.R.curves,o,e.preRotation,e.postRotation,e.eulerOrder);void 0!==r&&t.push(r)}if(void 0!==e.S&&Object.keys(e.S.curves).length>0){const r=this.generateVectorTrack(e.modelName,e.S.curves,l,"scale");void 0!==r&&t.push(r)}if(void 0!==e.DeformPercent){const r=this.generateMorphTrack(e);void 0!==r&&t.push(r)}return t}generateVectorTrack(e,t,r,o){const l=this.getTimesForAllAxes(t),c=this.getKeyframeTrackValues(l,t,r);return new n.VectorKeyframeTrack(e+"."+o,l,c)}generateRotationTrack(e,t,r,o,l,c){void 0!==t.x&&(this.interpolateRotations(t.x),t.x.values=t.x.values.map(n.MathUtils.degToRad)),void 0!==t.y&&(this.interpolateRotations(t.y),t.y.values=t.y.values.map(n.MathUtils.degToRad)),void 0!==t.z&&(this.interpolateRotations(t.z),t.z.values=t.z.values.map(n.MathUtils.degToRad));const h=this.getTimesForAllAxes(t),d=this.getKeyframeTrackValues(h,t,r);void 0!==o&&((o=o.map(n.MathUtils.degToRad)).push(c),o=(new n.Euler).fromArray(o),o=(new n.Quaternion).setFromEuler(o)),void 0!==l&&((l=l.map(n.MathUtils.degToRad)).push(c),l=(new n.Euler).fromArray(l),l=(new n.Quaternion).setFromEuler(l).invert());const f=new n.Quaternion,m=new n.Euler,v=[];for(let i=0;i<d.length;i+=3)m.set(d[i],d[i+1],d[i+2],c),f.setFromEuler(m),void 0!==o&&f.premultiply(o),void 0!==l&&f.multiply(l),f.toArray(v,i/3*4);return new n.QuaternionKeyframeTrack(e+".quaternion",h,v)}generateMorphTrack(e){const t=e.DeformPercent.curves.morph,r=t.values.map((function(e){return e/100})),o=d.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];return new n.NumberKeyframeTrack(e.modelName+".morphTargetInfluences["+o+"]",t.times,r)}getTimesForAllAxes(e){let t=[];if(void 0!==e.x&&(t=t.concat(e.x.times)),void 0!==e.y&&(t=t.concat(e.y.times)),void 0!==e.z&&(t=t.concat(e.z.times)),t=t.sort((function(a,b){return a-b})),t.length>1){let e=1,r=t[0];for(let i=1;i<t.length;i++){const n=t[i];n!==r&&(t[e]=n,r=n,e++)}t=t.slice(0,e)}return t}getKeyframeTrackValues(e,t,r){const n=r,o=[];let l=-1,c=-1,h=-1;return e.forEach((function(time){if(t.x&&(l=t.x.times.indexOf(time)),t.y&&(c=t.y.times.indexOf(time)),t.z&&(h=t.z.times.indexOf(time)),-1!==l){const e=t.x.values[l];o.push(e),n[0]=e}else o.push(n[0]);if(-1!==c){const e=t.y.values[c];o.push(e),n[1]=e}else o.push(n[1]);if(-1!==h){const e=t.z.values[h];o.push(e),n[2]=e}else o.push(n[2])})),o}interpolateRotations(e){for(let i=1;i<e.values.length;i++){const t=e.values[i-1],r=e.values[i]-t,n=Math.abs(r);if(n>=180){const o=n/180,l=r/o;let c=t+l;const h=e.times[i-1],d=(e.times[i]-h)/o;let f=h+d;const m=[],v=[];for(;f<e.times[i];)m.push(f),f+=d,v.push(c),c+=l;e.times=R(e.times,i,m),e.values=R(e.values,i,v)}}}}class w{getPrevNode(){return this.nodeStack[this.currentIndent-2]}getCurrentNode(){return this.nodeStack[this.currentIndent-1]}getCurrentProp(){return this.currentProp}pushStack(e){this.nodeStack.push(e),this.currentIndent+=1}popStack(){this.nodeStack.pop(),this.currentIndent-=1}setCurrentProp(e,t){this.currentProp=e,this.currentPropName=t}parse(text){this.currentIndent=0,this.allNodes=new T,this.nodeStack=[],this.currentProp=[],this.currentPropName="";const e=this,t=text.split(/[\r\n]+/);return t.forEach((function(line,i){const r=line.match(/^[\s\t]*;/),n=line.match(/^[\s\t]*$/);if(r||n)return;const o=line.match("^\\t{"+e.currentIndent+"}(\\w+):(.*){",""),l=line.match("^\\t{"+e.currentIndent+"}(\\w+):[\\s\\t\\r\\n](.*)"),c=line.match("^\\t{"+(e.currentIndent-1)+"}}");o?e.parseNodeBegin(line,o):l?e.parseNodeProperty(line,l,t[++i]):c?e.popStack():line.match(/^[^\s\t}]/)&&e.parseNodePropertyContinued(line)})),this.allNodes}parseNodeBegin(line,e){const t=e[1].trim().replace(/^"/,"").replace(/"$/,""),r=e[2].split(",").map((function(e){return e.trim().replace(/^"/,"").replace(/"$/,"")})),n={name:t},o=this.parseNodeAttr(r),l=this.getCurrentNode();0===this.currentIndent?this.allNodes.add(t,n):t in l?("PoseNode"===t?l.PoseNode.push(n):void 0!==l[t].id&&(l[t]={},l[t][l[t].id]=l[t]),""!==o.id&&(l[t][o.id]=n)):"number"==typeof o.id?(l[t]={},l[t][o.id]=n):"Properties70"!==t&&(l[t]="PoseNode"===t?[n]:n),"number"==typeof o.id&&(n.id=o.id),""!==o.name&&(n.attrName=o.name),""!==o.type&&(n.attrType=o.type),this.pushStack(n)}parseNodeAttr(e){let t=e[0];""!==e[0]&&(t=parseInt(e[0]),isNaN(t)&&(t=e[0]));let r="",n="";return e.length>1&&(r=e[1].replace(/^(\w+)::/,""),n=e[2]),{id:t,name:r,type:n}}parseNodeProperty(line,e,t){let r=e[1].replace(/^"/,"").replace(/"$/,"").trim(),n=e[2].replace(/^"/,"").replace(/"$/,"").trim();"Content"===r&&","===n&&(n=t.replace(/"/g,"").replace(/,$/,"").trim());const o=this.getCurrentNode();if("Properties70"!==o.name){if("C"===r){const e=n.split(",").slice(1),t=parseInt(e[0]),l=parseInt(e[1]);let c=n.split(",").slice(3);c=c.map((function(e){return e.trim().replace(/^"/,"")})),r="connections",n=[t,l],function(a,b){for(let i=0,e=a.length,t=b.length;i<t;i++,e++)a[e]=b[i]}(n,c),void 0===o[r]&&(o[r]=[])}"Node"===r&&(o.id=n),r in o&&Array.isArray(o[r])?o[r].push(n):"a"!==r?o[r]=n:o.a=n,this.setCurrentProp(o,r),"a"===r&&","!==n.slice(-1)&&(o.a=F(n))}else this.parseNodeSpecialProperty(line,r,n)}parseNodePropertyContinued(line){const e=this.getCurrentNode();e.a+=line,","!==line.slice(-1)&&(e.a=F(e.a))}parseNodeSpecialProperty(line,e,t){const r=t.split('",').map((function(e){return e.trim().replace(/^\"/,"").replace(/\s/,"_")})),n=r[0],o=r[1],l=r[2],c=r[3];let h=r[4];switch(o){case"int":case"enum":case"bool":case"ULongLong":case"double":case"Number":case"FieldOfView":h=parseFloat(h);break;case"Color":case"ColorRGB":case"Vector3D":case"Lcl_Translation":case"Lcl_Rotation":case"Lcl_Scaling":h=F(h)}this.getPrevNode()[n]={type:o,type2:l,flag:c,value:h},this.setCurrentProp(this.getPrevNode(),n)}}class I{parse(e){const t=new x(e);t.skip(23);const r=t.getUint32();if(r<6400)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+r);const n=new T;for(;!this.endOfContent(t);){const e=this.parseNode(t,r);null!==e&&n.add(e.name,e)}return n}endOfContent(e){return e.size()%16==0?(e.getOffset()+160+16&-16)>=e.size():e.getOffset()+160+16>=e.size()}parseNode(e,t){const r={},n=t>=7500?e.getUint64():e.getUint32(),o=t>=7500?e.getUint64():e.getUint32();t>=7500?e.getUint64():e.getUint32();const l=e.getUint8(),c=e.getString(l);if(0===n)return null;const h=[];for(let i=0;i<o;i++)h.push(this.parseProperty(e));const d=h.length>0?h[0]:"",f=h.length>1?h[1]:"",m=h.length>2?h[2]:"";for(r.singleProperty=1===o&&e.getOffset()===n;n>e.getOffset();){const n=this.parseNode(e,t);null!==n&&this.parseSubNode(c,r,n)}return r.propertyList=h,"number"==typeof d&&(r.id=d),""!==f&&(r.attrName=f),""!==m&&(r.attrType=m),""!==c&&(r.name=c),r}parseSubNode(e,t,r){if(!0===r.singleProperty){const e=r.propertyList[0];Array.isArray(e)?(t[r.name]=r,r.a=e):t[r.name]=e}else if("Connections"===e&&"C"===r.name){const e=[];r.propertyList.forEach((function(t,i){0!==i&&e.push(t)})),void 0===t.connections&&(t.connections=[]),t.connections.push(e)}else if("Properties70"===r.name){Object.keys(r).forEach((function(e){t[e]=r[e]}))}else if("Properties70"===e&&"P"===r.name){let e=r.propertyList[0],n=r.propertyList[1];const o=r.propertyList[2],l=r.propertyList[3];let c;0===e.indexOf("Lcl ")&&(e=e.replace("Lcl ","Lcl_")),0===n.indexOf("Lcl ")&&(n=n.replace("Lcl ","Lcl_")),c="Color"===n||"ColorRGB"===n||"Vector"===n||"Vector3D"===n||0===n.indexOf("Lcl_")?[r.propertyList[4],r.propertyList[5],r.propertyList[6]]:r.propertyList[4],t[e]={type:n,type2:o,flag:l,value:c}}else void 0===t[r.name]?"number"==typeof r.id?(t[r.name]={},t[r.name][r.id]=r):t[r.name]=r:"PoseNode"===r.name?(Array.isArray(t[r.name])||(t[r.name]=[t[r.name]]),t[r.name].push(r)):void 0===t[r.name][r.id]&&(t[r.name][r.id]=r)}parseProperty(e){const t=e.getString(1);let r;switch(t){case"C":return e.getBoolean();case"D":return e.getFloat64();case"F":return e.getFloat32();case"I":return e.getInt32();case"L":return e.getInt64();case"R":return r=e.getUint32(),e.getArrayBuffer(r);case"S":return r=e.getUint32(),e.getString(r);case"Y":return e.getInt16();case"b":case"c":case"d":case"f":case"i":case"l":const n=e.getUint32(),l=e.getUint32(),c=e.getUint32();if(0===l)switch(t){case"b":case"c":return e.getBooleanArray(n);case"d":return e.getFloat64Array(n);case"f":return e.getFloat32Array(n);case"i":return e.getInt32Array(n);case"l":return e.getInt64Array(n)}void 0===o&&console.error("THREE.FBXLoader: External library fflate.min.js required.");const data=o.unzlibSync(new Uint8Array(e.getArrayBuffer(c))),h=new x(data.buffer);switch(t){case"b":case"c":return h.getBooleanArray(n);case"d":return h.getFloat64Array(n);case"f":return h.getFloat32Array(n);case"i":return h.getInt32Array(n);case"l":return h.getInt64Array(n)}default:throw new Error("THREE.FBXLoader: Unknown property type "+t)}}}class x{constructor(e,t){this.dv=new DataView(e),this.offset=0,this.littleEndian=void 0===t||t}getOffset(){return this.offset}size(){return this.dv.buffer.byteLength}skip(e){this.offset+=e}getBoolean(){return 1==(1&this.getUint8())}getBooleanArray(e){const a=[];for(let i=0;i<e;i++)a.push(this.getBoolean());return a}getUint8(){const e=this.dv.getUint8(this.offset);return this.offset+=1,e}getInt16(){const e=this.dv.getInt16(this.offset,this.littleEndian);return this.offset+=2,e}getInt32(){const e=this.dv.getInt32(this.offset,this.littleEndian);return this.offset+=4,e}getInt32Array(e){const a=[];for(let i=0;i<e;i++)a.push(this.getInt32());return a}getUint32(){const e=this.dv.getUint32(this.offset,this.littleEndian);return this.offset+=4,e}getInt64(){let e,t;return this.littleEndian?(e=this.getUint32(),t=this.getUint32()):(t=this.getUint32(),e=this.getUint32()),2147483648&t?(t=4294967295&~t,e=4294967295&~e,4294967295===e&&(t=t+1&4294967295),e=e+1&4294967295,-(4294967296*t+e)):4294967296*t+e}getInt64Array(e){const a=[];for(let i=0;i<e;i++)a.push(this.getInt64());return a}getUint64(){let e,t;return this.littleEndian?(e=this.getUint32(),t=this.getUint32()):(t=this.getUint32(),e=this.getUint32()),4294967296*t+e}getFloat32(){const e=this.dv.getFloat32(this.offset,this.littleEndian);return this.offset+=4,e}getFloat32Array(e){const a=[];for(let i=0;i<e;i++)a.push(this.getFloat32());return a}getFloat64(){const e=this.dv.getFloat64(this.offset,this.littleEndian);return this.offset+=8,e}getFloat64Array(e){const a=[];for(let i=0;i<e;i++)a.push(this.getFloat64());return a}getArrayBuffer(e){const t=this.dv.buffer.slice(this.offset,this.offset+e);return this.offset+=e,t}getString(e){let a=[];for(let i=0;i<e;i++)a[i]=this.getUint8();const t=a.indexOf(0);return t>=0&&(a=a.slice(0,t)),n.LoaderUtils.decodeText(new Uint8Array(a))}}class T{add(e,t){this[e]=t}}function M(text){const e=text.match(/FBXVersion: (\d+)/);if(e){return parseInt(e[1])}throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.")}function E(time){return time/46186158e3}const A=[];function D(e,t,r,n){let o;switch(n.mappingType){case"ByPolygonVertex":o=e;break;case"ByPolygon":o=t;break;case"ByVertice":o=r;break;case"AllSame":o=n.indices[0];break;default:console.warn("THREE.FBXLoader: unknown attribute mapping type "+n.mappingType)}"IndexToDirect"===n.referenceType&&(o=n.indices[o]);const l=o*n.dataSize,c=l+n.dataSize;return function(a,b,e,t){for(let i=e,r=0;i<t;i++,r++)a[r]=b[i];return a}(A,n.buffer,l,c)}const P=new n.Euler,L=new n.Vector3;function C(e){const t=new n.Matrix4,r=new n.Matrix4,o=new n.Matrix4,l=new n.Matrix4,c=new n.Matrix4,h=new n.Matrix4,d=new n.Matrix4,f=new n.Matrix4,m=new n.Matrix4,v=new n.Matrix4,y=new n.Matrix4,w=new n.Matrix4,I=e.inheritType?e.inheritType:0;if(e.translation&&t.setPosition(L.fromArray(e.translation)),e.preRotation){const t=e.preRotation.map(n.MathUtils.degToRad);t.push(e.eulerOrder),r.makeRotationFromEuler(P.fromArray(t))}if(e.rotation){const t=e.rotation.map(n.MathUtils.degToRad);t.push(e.eulerOrder),o.makeRotationFromEuler(P.fromArray(t))}if(e.postRotation){const t=e.postRotation.map(n.MathUtils.degToRad);t.push(e.eulerOrder),l.makeRotationFromEuler(P.fromArray(t)),l.invert()}e.scale&&c.scale(L.fromArray(e.scale)),e.scalingOffset&&d.setPosition(L.fromArray(e.scalingOffset)),e.scalingPivot&&h.setPosition(L.fromArray(e.scalingPivot)),e.rotationOffset&&f.setPosition(L.fromArray(e.rotationOffset)),e.rotationPivot&&m.setPosition(L.fromArray(e.rotationPivot)),e.parentMatrixWorld&&(y.copy(e.parentMatrix),v.copy(e.parentMatrixWorld));const x=r.clone().multiply(o).multiply(l),T=new n.Matrix4;T.extractRotation(v);const M=new n.Matrix4;M.copyPosition(v);const E=M.clone().invert().multiply(v),A=T.clone().invert().multiply(E),D=c,C=new n.Matrix4;if(0===I)C.copy(T).multiply(x).multiply(A).multiply(D);else if(1===I)C.copy(T).multiply(A).multiply(x).multiply(D);else{const e=(new n.Matrix4).scale((new n.Vector3).setFromMatrixScale(y)).clone().invert(),t=A.clone().multiply(e);C.copy(T).multiply(x).multiply(t).multiply(D)}const N=m.clone().invert(),F=h.clone().invert();let k=t.clone().multiply(f).multiply(m).multiply(r).multiply(o).multiply(l).multiply(N).multiply(d).multiply(h).multiply(c).multiply(F);const R=(new n.Matrix4).copyPosition(k),O=v.clone().multiply(R);return w.copyPosition(O),k=w.clone().multiply(C),k.premultiply(v.invert()),k}function N(e){const t=["ZYX","YZX","XZY","ZXY","YXZ","XYZ"];return 6===(e=e||0)?(console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."),t[0]):t[e]}function F(e){return e.split(",").map((function(e){return parseFloat(e)}))}function k(e,t,r){return void 0===t&&(t=0),void 0===r&&(r=e.byteLength),n.LoaderUtils.decodeText(new Uint8Array(e,t,r))}function R(e,t,r){return e.slice(0,t).concat(r).concat(e.slice(t))}},831:function(e,t,r){"use strict";r.d(t,"a",(function(){return n}));class n{constructor(e=Math){this.grad3=[[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],[1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],[0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]],this.grad4=[[0,1,1,1],[0,1,1,-1],[0,1,-1,1],[0,1,-1,-1],[0,-1,1,1],[0,-1,1,-1],[0,-1,-1,1],[0,-1,-1,-1],[1,0,1,1],[1,0,1,-1],[1,0,-1,1],[1,0,-1,-1],[-1,0,1,1],[-1,0,1,-1],[-1,0,-1,1],[-1,0,-1,-1],[1,1,0,1],[1,1,0,-1],[1,-1,0,1],[1,-1,0,-1],[-1,1,0,1],[-1,1,0,-1],[-1,-1,0,1],[-1,-1,0,-1],[1,1,1,0],[1,1,-1,0],[1,-1,1,0],[1,-1,-1,0],[-1,1,1,0],[-1,1,-1,0],[-1,-1,1,0],[-1,-1,-1,0]],this.p=[];for(let i=0;i<256;i++)this.p[i]=Math.floor(256*e.random());this.perm=[];for(let i=0;i<512;i++)this.perm[i]=this.p[255&i];this.simplex=[[0,1,2,3],[0,1,3,2],[0,0,0,0],[0,2,3,1],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,2,3,0],[0,2,1,3],[0,0,0,0],[0,3,1,2],[0,3,2,1],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,3,2,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,2,0,3],[0,0,0,0],[1,3,0,2],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,3,0,1],[2,3,1,0],[1,0,2,3],[1,0,3,2],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,0,3,1],[0,0,0,0],[2,1,3,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,0,1,3],[0,0,0,0],[0,0,0,0],[0,0,0,0],[3,0,1,2],[3,0,2,1],[0,0,0,0],[3,1,2,0],[2,1,0,3],[0,0,0,0],[0,0,0,0],[0,0,0,0],[3,1,0,2],[0,0,0,0],[3,2,0,1],[3,2,1,0]]}dot(g,e,t){return g[0]*e+g[1]*t}dot3(g,e,t,r){return g[0]*e+g[1]*t+g[2]*r}dot4(g,e,t,r,n){return g[0]*e+g[1]*t+g[2]*r+g[3]*n}noise(e,t){let r,n,o;const s=(e+t)*(.5*(Math.sqrt(3)-1)),i=Math.floor(e+s),l=Math.floor(t+s),c=(3-Math.sqrt(3))/6,h=(i+l)*c,d=e-(i-h),f=t-(l-h);let m,v;d>f?(m=1,v=0):(m=0,v=1);const y=d-m+c,w=f-v+c,I=d-1+2*c,x=f-1+2*c,T=255&i,M=255&l,E=this.perm[T+this.perm[M]]%12,A=this.perm[T+m+this.perm[M+v]]%12,D=this.perm[T+1+this.perm[M+1]]%12;let P=.5-d*d-f*f;P<0?r=0:(P*=P,r=P*P*this.dot(this.grad3[E],d,f));let L=.5-y*y-w*w;L<0?n=0:(L*=L,n=L*L*this.dot(this.grad3[A],y,w));let C=.5-I*I-x*x;return C<0?o=0:(C*=C,o=C*C*this.dot(this.grad3[D],I,x)),70*(r+n+o)}noise3d(e,t,r){let n,o,l,c;const s=(e+t+r)*(1/3),i=Math.floor(e+s),h=Math.floor(t+s),d=Math.floor(r+s),f=1/6,m=(i+h+d)*f,v=e-(i-m),y=t-(h-m),w=r-(d-m);let I,x,T,M,E,A;v>=y?y>=w?(I=1,x=0,T=0,M=1,E=1,A=0):v>=w?(I=1,x=0,T=0,M=1,E=0,A=1):(I=0,x=0,T=1,M=1,E=0,A=1):y<w?(I=0,x=0,T=1,M=0,E=1,A=1):v<w?(I=0,x=1,T=0,M=0,E=1,A=1):(I=0,x=1,T=0,M=1,E=1,A=0);const D=v-I+f,P=y-x+f,L=w-T+f,C=v-M+2*f,N=y-E+2*f,F=w-A+2*f,k=v-1+.5,R=y-1+.5,O=w-1+.5,S=255&i,B=255&h,U=255&d,V=this.perm[S+this.perm[B+this.perm[U]]]%12,j=this.perm[S+I+this.perm[B+x+this.perm[U+T]]]%12,G=this.perm[S+M+this.perm[B+E+this.perm[U+A]]]%12,X=this.perm[S+1+this.perm[B+1+this.perm[U+1]]]%12;let W=.6-v*v-y*y-w*w;W<0?n=0:(W*=W,n=W*W*this.dot3(this.grad3[V],v,y,w));let z=.6-D*D-P*P-L*L;z<0?o=0:(z*=z,o=z*z*this.dot3(this.grad3[j],D,P,L));let H=.6-C*C-N*N-F*F;H<0?l=0:(H*=H,l=H*H*this.dot3(this.grad3[G],C,N,F));let _=.6-k*k-R*R-O*O;return _<0?c=0:(_*=_,c=_*_*this.dot3(this.grad3[X],k,R,O)),32*(n+o+l+c)}noise4d(e,t,r,n){const o=this.grad4,l=this.simplex,c=this.perm,h=(Math.sqrt(5)-1)/4,d=(5-Math.sqrt(5))/20;let f,m,v,y,w;const s=(e+t+r+n)*h,i=Math.floor(e+s),I=Math.floor(t+s),x=Math.floor(r+s),T=Math.floor(n+s),M=(i+I+x+T)*d,E=e-(i-M),A=t-(I-M),D=r-(x-M),P=n-(T-M),L=(E>A?32:0)+(E>D?16:0)+(A>D?8:0)+(E>P?4:0)+(A>P?2:0)+(D>P?1:0),C=l[L][0]>=3?1:0,N=l[L][1]>=3?1:0,F=l[L][2]>=3?1:0,k=l[L][3]>=3?1:0,R=l[L][0]>=2?1:0,O=l[L][1]>=2?1:0,S=l[L][2]>=2?1:0,B=l[L][3]>=2?1:0,U=l[L][0]>=1?1:0,V=l[L][1]>=1?1:0,j=l[L][2]>=1?1:0,G=l[L][3]>=1?1:0,X=E-C+d,W=A-N+d,z=D-F+d,H=P-k+d,_=E-R+2*d,K=A-O+2*d,Y=D-S+2*d,Z=P-B+2*d,Q=E-U+3*d,$=A-V+3*d,J=D-j+3*d,ee=P-G+3*d,te=E-1+4*d,re=A-1+4*d,ne=D-1+4*d,oe=P-1+4*d,ae=255&i,se=255&I,ie=255&x,le=255&T,ce=c[ae+c[se+c[ie+c[le]]]]%32,ue=c[ae+C+c[se+N+c[ie+F+c[le+k]]]]%32,pe=c[ae+R+c[se+O+c[ie+S+c[le+B]]]]%32,he=c[ae+U+c[se+V+c[ie+j+c[le+G]]]]%32,de=c[ae+1+c[se+1+c[ie+1+c[le+1]]]]%32;let fe=.6-E*E-A*A-D*D-P*P;fe<0?f=0:(fe*=fe,f=fe*fe*this.dot4(o[ce],E,A,D,P));let me=.6-X*X-W*W-z*z-H*H;me<0?m=0:(me*=me,m=me*me*this.dot4(o[ue],X,W,z,H));let ge=.6-_*_-K*K-Y*Y-Z*Z;ge<0?v=0:(ge*=ge,v=ge*ge*this.dot4(o[pe],_,K,Y,Z));let ve=.6-Q*Q-$*$-J*J-ee*ee;ve<0?y=0:(ve*=ve,y=ve*ve*this.dot4(o[he],Q,$,J,ee));let ye=.6-te*te-re*re-ne*ne-oe*oe;return ye<0?w=0:(ye*=ye,w=ye*ye*this.dot4(o[de],te,re,ne,oe)),27*(f+m+v+y+w)}}}}]);